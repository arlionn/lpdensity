{
    "collab_server" : "",
    "contents" : "################################################################################\n#' @title  Local Polynomial Density Estimation and Inference\n#'\n#' @description \\code{lpdensity} implements the local polynomial regression based density (and derivatives)\n#'   estimator proposed in \\href{http://www-personal.umich.edu/~cattaneo/papers/Cattaneo-Jansson-Ma_2017_LocPolDensity.pdf}{Cattaneo, Jansson and Ma (2017a)}. This command can also be\n#'   used to obtain smoothed estimates for cumulative distribution functions. See\n#'   \\href{http://www-personal.umich.edu/~cattaneo/papers/Cattaneo-Jansson-Ma_2017_lpdensity.pdf}{Cattaneo, Jansson and Ma (2017b)} for more implementation details and illustrations.\n#'\n#'   Companion command: \\code{\\link{lpbwdensity}} for data-driven bandwidth selection,\n#'   and \\code{\\link{lpdensity.plot}} for density plot with robust confidence interval.\n#'\n#'   For more details, and related Stata and R packages useful for empirical analysis,\n#'   visit \\url{https://sites.google.com/site/nppackages/}.\n#'\n#' @param data Numeric vector or one dimensional matrix / data frame, the raw data.\n#' @param grid Numeric vector or one dimensional matrix / data frame, the grid on which\n#'   density is estimated. When set to default, grid points will be chosen as 0.05-0.95\n#'   percentiles of the data, with 0.05 step size.\n#' @param bw Numeric vector or one dimensional matrix / data frame, the bandwidth\n#'   used for estimation. Can be (1) a positive scalar (common\n#'   bandwidth for all grid points); or (2) a positive numeric vector specifying bandwidths for\n#'   each grid point (should be the same length as \\code{grid}).\n#' @param p Integer, nonnegative, the order of the local-polynomial used to construct point\n#'   estimates. (Default is 2.)\n#' @param q Integer, nonnegative, the order of the local-polynomial used to construct pointwise\n#'   confidence interval (a.k.a. the bias correction order). Default is \\code{p+1}. When specified\n#'   the same as \\code{p}, no bias correction will be performed. Otherwise it should be\n#'   strictly larger than \\code{p}.\n#' @param v Integer, nonnegative, the derivative of distribution function to be estimated. \\code{0} for\n#'   the distribution function, \\code{1} (default) for the density funtion, etc.\n#' @param bwselect String, the method for data-driven bandwidth selection. This option will be\n#'   ignored if \\code{bw} is provided. Can be (1) \\code{\"mse-dpi\"} (default, mean squared error-optimal\n#'   bandwidth selected for each grid point); or (2) \\code{\"imse-dpi\"} (integrated MSE-optimal bandwidth,\n#'   common for all grid points); (3) \\code{\"mse-rot\"} (rule-of-thumb bandwidth with Gaussian\n#'   reference model); and (4) \\code{\"imse-rot\"} (integrated rule-of-thumb bandwidth with Gaussian\n#'   reference model).\n#' @param kernel String, the kernel function, should be one of \\code{\"triangular\"}, \\code{\"uniform\"} or\n#'   \\code{\"epanechnikov\"}.\n#' @param Cweights, Numeric vector or one dimensional matrix / data frame, the weights used\n#'   for counterfactual distribution construction. Should have the same length as sample size.\n#' @param Pweights Numeric vector or one dimensional matrix / data frame, the weights used\n#'   in sampling. Should have the same length as sample size and nonnegative.\n#' @param scale Numeric, scaling factor for the final estimate. This parameter controls how\n#'   estimates are scaled. For example, setting this parameter to 0.5 will scale down both the\n#'   point estimates and standard errors by half. By default it is 1. This parameter is used if only\n#'   part of the sample is used for estimation, and should not be confused with \\code{Cweights}\n#'   or \\code{Pweights}.\n#'\n#' @return\n#' \\item{Estimate}{A matrix containing (1) \\code{grid} (grid points), (2) \\code{bw} (bandwidths), (3) \\code{nh}\n#'   (effective/local sample sizes), (4) \\code{f_p} (point estimates with p-th order local polynomial),\n#'   (5) \\code{f_q} (point estimates with q-th order local polynomial, only if option \\code{q} is nonzero),\n#'   (6) \\code{se_p} (standard error corresponding to \\code{f_p}), and (7) \\code{se_q} (standard error\n#'   corresponding to \\code{f_q}).}\n#' \\item{opt}{A list containing options passed to the function.}\n#'\n#' @references\n#' M. D. Cattaneo, M. Jansson and X. Ma. (2017a). \\href{http://www-personal.umich.edu/~cattaneo/papers/Cattaneo-Jansson-Ma_2017_LocPolDensity.pdf}{Simple Local Polynomial Density Estimators}. Working Paper, University of Michigan.\n#'\n#' M. D. Cattaneo, M. Jansson and X. Ma. (2017b). \\href{http://www-personal.umich.edu/~cattaneo/papers/Cattaneo-Jansson-Ma_2017_lpdensity.pdf}{\\code{lpdensity}: Local Polynomial Density Estimation and Inference}. Working Paper, University of Michigan.\n#'\n#' @author\n#' Matias D. Cattaneo, University of Michigan. \\email{cattaneo@umich.edu}.\n#'\n#' Michael Jansson, University of California, Berkeley. \\email{mjansson@econ.berkeley.edu}.\n#'\n#' Xinwei Ma (maintainer), University of Michigan. \\email{xinweima@umich.edu}.\n#'\n#' @seealso \\code{\\link{lpbwdensity}} and \\code{\\link{lpdensity.plot}}.\n#'\n#' @examples\n#' set.seed(42); X <- rnorm(2000)\n#' est1 <- lpdensity(data = X, bwselect = \"imse-dpi\")\n#' summary(est1)\n#'\n#' @export\nlpdensity <- function(data, grid=NULL, bw=NULL, p=NULL, q=NULL, v=NULL,\n                      bwselect=c(\"mse-dpi\", \"imse-dpi\", \"mse-rot\", \"imse-rot\"),\n                      kernel=c(\"triangular\", \"uniform\", \"epanechnikov\"),\n                      Cweights=NULL, Pweights=NULL, scale=NULL) {\n  ################################################################################\n  # Input Error Handling\n  ################################################################################\n  # data\n  data <- as.vector(data)\n  if (any(is.na(data))) {\n    warning(\"Missing data will be ignored.\\n\")\n    data <- data[!is.na(data)]\n  }\n  n <- length(data)\n  if (!is.numeric(data) | length(data)==0) {\n    stop(\"Data has to be numeric, and cannot be empty.\\n\")\n  }\n\n  # grid\n  if (length(grid) == 0) {\n    flag_no_grid <- TRUE\n    grid <- quantile(data, seq(from=0.05, to=0.95, by=0.05))\n    ng <- length(grid)\n  } else {\n    flag_no_grid <- FALSE\n    grid <- as.vector(grid)\n    ng <- length(grid)\n    if(!is.numeric(grid)) {\n      stop(\"Grid points has to be numeric.\\n\")\n    }\n  }\n\n  # bw\n  if (length(bw) == 0) {\n    flag_no_bw <- TRUE\n    if (length(bwselect) == 0) {\n      bwselect <- \"mse-dpi\"\n    } else {\n      bwselect <- tolower(bwselect[1])\n      # for\n    }\n    ### BACKWARD COMPATIBILITY FOR VERSION 0.1\n    if (bwselect == \"mse\" ) { bwselect <- \"mse-dpi\" }\n    if (bwselect == \"imse\") { bwselect <- \"imse-dpi\" }\n    if (bwselect == \"rot\" ) { bwselect <- \"mse-rot\" }\n    if (bwselect == \"irot\") { bwselect <- \"imse-rot\" }\n    ### END BACKWARD COMPATIBILITY FOR VERSION 0.1\n\n    if (!bwselect%in%c(\"mse-dpi\", \"imse-dpi\", \"mse-rot\", \"imse-rot\")) stop(\"Incorrect bandwidth selection method specified.\\n\")\n  } else if (length(bw) == 1) {\n    if (!is.numeric(bw) | bw <= 0) {\n      stop(\"Bandwidth incorrectly specified.\\n\")\n    } else {\n      flag_no_bw <- FALSE\n      bw <- rep(bw, ng)\n      bwselect <- \"user provided\"\n    }\n  } else {\n    bw <- as.vector(bw)\n    if (!is.numeric(bw)) {\n      stop(\"Bandwidth incorrectly specified.\\n\")\n    } else if (length(bw) != ng) {\n      stop(\"Bandwidth has to be the same length as grid.\\n\")\n    } else {\n      bwselect <- \"user provided\"\n      flag_no_bw <- FALSE\n    }\n  }\n\n  # p\n  if (length(p) == 0) {\n    flag_no_p <- TRUE\n    p <- 2\n  } else if ((length(p) != 1) | !(p[1]%in%0:20)) {\n    stop(\"Polynomial order p incorrectly specified.\\n\")\n  } else {\n    flag_no_p <- FALSE\n  }\n\n  # q\n  if (length(q) == 0) {\n    flag_no_q <- TRUE\n    q <- p + 1\n  } else if ((length(q) > 1) | !(q[1]%in%c(0:20)) | (q[1]<p)) {\n    stop(\"Polynomial order (for bias correction) q incorrectly specified.\\n\")\n  } else {\n    flag_no_q <- FALSE\n  }\n\n  # v\n  if (length(v) == 0) {\n    flag_no_v <- TRUE\n    v <- min(1, p)\n  } else if ((length(v) > 1) | !(v[1]%in%c(0:20)) | (v[1]>p)) {\n    stop(\"Derivative order v incorrectly specified.\\n\")\n  } else {\n    flag_no_v <- FALSE\n  }\n\n  # kernel\n  if (length(kernel) == 0) {\n    flag_no_kernel <- TRUE\n    kernel <- \"triangular\"\n  } else {\n    kernel <- tolower(kernel)\n    kernel <- kernel[1]\n    if (!kernel%in%c(\"triangular\", \"uniform\", \"epanechnikov\")) {\n      stop(\"Kernel function incorrectly specified.\\n\")\n    } else {\n      flag_no_kernel <- FALSE\n    }\n  }\n\n  # Cweights\n  if (length(Cweights) == 0) {\n    flag_no_Cweights <- TRUE\n    Cweights <- rep(1, n)\n  } else if (!is.numeric(Cweights)) {\n    stop(\"Counterfactual weights incorrectly specified.\\n\")\n  } else if (length(Cweights) != n) {\n    stop(\"Counterfactual weights has to be the same length as sample.\\n\")\n  } else {\n    flag_no_Cweights <- FALSE\n  }\n\n  # Pweights\n  if (length(Pweights) == 0) {\n    flag_no_Pweights <- TRUE\n    Pweights <- rep(1, n)\n  } else if (!is.numeric(Pweights)) {\n    stop(\"Probability weights incorrectly specified.\\n\")\n  } else if (length(Pweights) != n) {\n    stop(\"Probability weights has to be the same length as sample.\\n\")\n  } else if (any(Pweights < 0)) {\n    stop(\"Probability weights has to be nonnegative.\\n\")\n  } else{\n    flag_no_Pweights <- FALSE\n  }\n\n  # scale\n  if (length(scale) == 0) {\n    flag_no_scale <- TRUE\n    scale <- 1\n  } else if (length(scale) > 1 | !is.numeric(scale) | scale < 0) {\n    stop(\"Scale incorrectly specified.\\n\")\n  } else {\n    flag_no_scale <- FALSE\n  }\n\n  ################################################################################\n  # Sample trimming\n  ################################################################################\n  trim_index <- (Pweights == 0)\n  if (all(trim_index)) {\n    stop(\"All weights are zero.\\n\")\n  }\n  if (any(trim_index)) {\n    data <- data[!trim_index]\n    Cweights <- Cweights[!trim_index]\n    Pweights <- Pweights[!trim_index]\n  }\n  if (abs(sum(Cweights * Pweights)) <= .Machine$double.eps * 10) {\n    stop(\"Composited weights (Cweights * Pweights) are numerically zero.\\n\")\n  }\n  if (length(data) < 50 + p + 1) stop(\"Not enough observations.\\n\")\n\n  ################################################################################\n  # Bandwidth selection\n  ################################################################################\n\n  if (flag_no_bw & bwselect[1]==\"mse-rot\") {\n    temp <- bw_ROT(data=data, grid=grid, p=p, v=v, kernel=kernel, regularize=TRUE)\n    temp[is.na(temp)] <- 0\n    bw <- temp\n  }\n  if (flag_no_bw & bwselect[1]==\"imse-rot\") {\n    temp <- bw_IROT(data=data, grid=grid, p=p, v=v, kernel=kernel, regularize=TRUE)\n    if (is.na(temp)) temp <- 0\n    bw <- rep(temp, ng)\n  }\n  if (flag_no_bw & bwselect[1]==\"mse-dpi\") {\n    temp <- bw_MSE(data=data, grid=grid, p=p, v=v, kernel=kernel, Cweights=Cweights, Pweights=Pweights, regularize=TRUE)\n    temp[is.na(temp)] <- 0\n    bw <- temp\n  }\n  if (flag_no_bw & bwselect[1]==\"imse-dpi\") {\n    temp <- bw_IMSE(data=data, grid=grid, p=p, v=v, kernel=kernel, Cweights=Cweights, Pweights=Pweights, regularize=TRUE)\n    if (is.na(temp)) temp <- 0\n    bw <- rep(temp, ng)\n  }\n\n  ################################################################################\n  # Point Estimation\n  ################################################################################\n  Estimate <- lpdensity_fn(data=data, grid=grid, bw=bw, p=p, q=q, v=v, kernel=kernel,\n                       Cweights=Cweights, Pweights=Pweights, showSE=TRUE)\n  Estimate[, c(\"f_p\", \"f_q\", \"se_p\", \"se_q\")] <- Estimate[, c(\"f_p\", \"f_q\", \"se_p\", \"se_q\")] * scale\n\n  row.names(Estimate) <- 1:ng\n\n  Result <- list(Estimate=Estimate,\n                 opt=list(\n                   p=p, q=q, v=v, kernel=kernel, scale=scale, n=n, ng=ng,\n                   bwselect=bwselect,\n                   data_min=min(data), data_max=max(data),\n                   grid_min=min(grid), grid_max=max(grid)\n                 ))\n  class(Result) <- \"CJMlpdensity\"\n\n  ################################################################################\n  # Bootstrap\n  ################################################################################\n\n  ################################################################################\n  # Return\n  ################################################################################\n  return(Result)\n}\n\n################################################################################\n#' Internal function.\n#'\n#' @param x Class \\code{CJMlpdensity} objects.\n#'\n#' @keywords internal\n#' @export\nprint.CJMlpdensity <- function(x, ...) {\n\n  cat(\"Call: lpdensity\\n\\n\")\n\n  cat(paste(\"Sample size                                      \", x$opt$n,        \"\\n\", sep=\"\"))\n  cat(paste(\"Polynomial order for point estimation    (p=)    \", x$opt$p,        \"\\n\", sep=\"\"))\n  cat(paste(\"Order of derivative estimated            (v=)    \", x$opt$v,        \"\\n\", sep=\"\"))\n  if (x$opt$q > 0) {\n    cat(paste(\"Polynomial order for confidence interval (q=)    \", x$opt$q,        \"\\n\", sep=\"\"))\n  } else {\n    cat(paste(\"Polynomial order for confidence interval (q=)    \", \"p\",            \"\\n\", sep=\"\"))\n  }\n  cat(paste(\"Kernel function                                  \", x$opt$kernel,   \"\\n\", sep=\"\"))\n  if (x$opt$scale != 1) {\n    cat(paste(\"Scaling factor                                   \",  x$opt$scale,   \"\\n\", sep=\"\"))\n  }\n  cat(paste(\"Bandwidth method                                 \", x$opt$bwselect, \"\\n\", sep=\"\"))\n  cat(\"\\n\")\n\n  cat(\"Use summary(...) to show estimates.\\n\")\n}\n\n################################################################################\n#' Internal function.\n#'\n#' @param object Class \\code{CJMlpdensity} objects.\n#'\n#' @keywords internal\n#' @export\nsummary.CJMlpdensity <- function(object, ...) {\n  x <- object\n  args <- list(...)\n  if (is.null(args[['alpha']])) { alpha <- 0.05 } else { alpha <- args[['alpha']] }\n  if (is.null(args[['sep']]))   { sep <- 5 } else { sep <- args[['sep']] }\n\n  cat(\"Call: lpdensity\\n\\n\")\n\n  cat(paste(\"Sample size                              (n=)    \", x$opt$n,        \"\\n\", sep=\"\"))\n  cat(paste(\"Polynomial order for point estimation    (p=)    \", x$opt$p,        \"\\n\", sep=\"\"))\n  if (x$opt$v == 0) {\n  cat(paste(\"Distribution function estimated          (v=)    \", x$opt$v,        \"\\n\", sep=\"\"))\n  } else if (x$opt$v == 1) {\n  cat(paste(\"Density function estimated               (v=)    \", x$opt$v,        \"\\n\", sep=\"\"))\n  } else {\n  cat(paste(\"Order of derivative estimated            (v=)    \", x$opt$v,        \"\\n\", sep=\"\"))\n  }\n  if (x$opt$q > x$opt$p) {\n  cat(paste(\"Polynomial order for confidence interval (q=)    \", x$opt$q,        \"\\n\", sep=\"\"))\n  } else {\n  cat(paste(\"Polynomial order for confidence interval (q=)    \", \"p\",            \"\\n\", sep=\"\"))\n  }\n  cat(paste(\"Kernel function                                  \", x$opt$kernel,   \"\\n\", sep=\"\"))\n  if (x$opt$scale != 1) {\n  cat(paste(\"Scaling factor                                   \",  x$opt$scale,   \"\\n\", sep=\"\"))\n  }\n  cat(paste(\"Bandwidth selection method                       \", x$opt$bwselect, \"\\n\", sep=\"\"))\n  cat(\"\\n\")\n\n  ### compute CI\n  z <- qnorm(1 - alpha / 2)\n\n  if (x$opt$q == x$opt$p) {\n    CI_l <- x$Estimate[, \"f_p\"] - x$Estimate[, \"se_p\"] * z;\n    CI_r <- x$Estimate[, \"f_p\"] + x$Estimate[, \"se_p\"] * z;\n  } else {\n    CI_l <- x$Estimate[, \"f_q\"] - x$Estimate[, \"se_q\"] * z;\n    CI_r <- x$Estimate[, \"f_q\"] + x$Estimate[, \"se_q\"] * z;\n  }\n\n  ### print output\n  cat(paste(rep(\"=\", 14 + 10 + 8 + 10 + 10 + 25), collapse=\"\")); cat(\"\\n\")\n\n  if (x$opt$q > x$opt$p) {\n    cat(format(\" \", width= 14 ))\n    cat(format(\" \", width= 10 ))\n    cat(format(\" \", width= 8  ))\n    cat(format(\"Point\", width= 10, justify=\"right\"))\n    cat(format(\"Std.\" , width= 10, justify=\"right\"))\n    cat(format(\"Robust B.C.\"\n               , width=25, justify=\"centre\"))\n    cat(\"\\n\")\n  } else {\n    cat(format(\" \", width= 14 ))\n    cat(format(\" \", width= 10 ))\n    cat(format(\" \", width=  8 ))\n    cat(format(\"Point\", width= 10, justify=\"right\"))\n    cat(format(\"Std.\" , width= 10, justify=\"right\"))\n    cat(format(\"Conventional\"\n               , width=25, justify=\"centre\"))\n    cat(\"\\n\")\n  }\n\n  cat(format(\"grid\"            , width=14, justify=\"right\"))\n  cat(format(\"bw\"              , width=10, justify=\"right\"))\n  cat(format(\"Eff.n\"           , width=8 , justify=\"right\"))\n  cat(format(\"Est.\"            , width=10, justify=\"right\"))\n  cat(format(\"Error\"           , width=10, justify=\"right\"))\n  cat(format(paste(\"[ \", floor((1-alpha)*100), \"%\", \" C.I. ]\", sep=\"\")\n                               , width=25, justify=\"centre\"))\n  cat(\"\\n\")\n\n  cat(paste(rep(\"=\", 14 + 10 + 8 + 10 + 10 + 25), collapse=\"\")); cat(\"\\n\")\n\n  for (j in 1:nrow(x$Estimate)) {\n    cat(format(toString(j), width=4))\n    cat(format(sprintf(\"%6.4f\", x$Estimate[j, \"grid\"]), width=10, justify=\"right\"))\n    cat(format(sprintf(\"%6.4f\", x$Estimate[j, \"bw\"])  , width=10, justify=\"right\"))\n    cat(format(sprintf(\"%8.0f\", x$Estimate[j, \"nh\"])  , width=8 , justify=\"right\"))\n    cat(format(sprintf(\"%6.4f\", x$Estimate[j, \"f_p\"]) , width=10, justify=\"right\"))\n    cat(format(\n      paste(sprintf(\"%6.4f\", x$Estimate[j, \"se_p\"]), sep=\"\"), width=10, justify=\"right\"))\n    cat(format(\n      paste(sprintf(\"%7.4f\", CI_l[j]), \" , \", sep=\"\")  , width=14, justify=\"right\"))\n    cat(format(\n      paste(sprintf(\"%7.4f\", CI_r[j]), sep=\"\"), width=11, justify=\"left\"))\n    cat(\"\\n\")\n    if (is.numeric(sep)) if (sep > 0) if (j %% sep == 0) {\n      cat(paste(rep(\"-\", 14 + 10 + 8 + 10 + 10 + 25), collapse=\"\")); cat(\"\\n\")\n    }\n  }\n\n  cat(paste(rep(\"=\", 14 + 10 + 8 + 10 + 10 + 25), collapse=\"\")); cat(\"\\n\")\n}\n\n",
    "created" : 1499456431787.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2607366650",
    "id" : "957CFC95",
    "lastKnownWriteTime" : 1499456483,
    "last_content_update" : 1499456483619,
    "path" : "~/Dropbox/0_Research/2017_lp_density/Package_R_lpdensity/lpdensity/R/lpdensity.R",
    "project_path" : "R/lpdensity.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}