{
    "collab_server" : "",
    "contents" : "################################################################################\n#' @title Data-driven Bandwidth Selection for Local Polynomial Density Estimators\n#'\n#' @description \\code{lpbwdensity} implements the bandwidth selector for local polynomial\n#'   based density (and derivatives) estimation, proposed in \\href{http://www-personal.umich.edu/~cattaneo/papers/Cattaneo-Jansson-Ma_2017_LocPolDensity.pdf}{Cattaneo, Jansson and Ma (2017a)}.\n#'   See \\href{http://www-personal.umich.edu/~cattaneo/papers/Cattaneo-Jansson-Ma_2017_lpdensity.pdf}{Cattaneo, Jansson and Ma (2017b)} for more implementation details and illustrations.\n#'\n#'   Companion command: \\code{\\link{lpdensity}} for local polynomial density estimation.\n#'\n#'   For more details, and related Stata and R packages useful for empirical analysis,\n#'   visit \\url{https://sites.google.com/site/nppackages/}.\n#'\n#' @param data Numeric vector or one dimensional matrix / data frame, the raw data.\n#' @param grid Numeric vector or one dimensional matrix / data frame, the grid on which\n#'   density is estimated. When set to default, grid points will be chosen as 0.05-0.95\n#'   percentiles of the data, with 0.05 step size.\n#' @param bwselect String, the method for data-driven bandwidth selection. This option will be\n#'   ignored if \\code{bw} is provided. Can be (1) \\code{\"mse-dpi\"} (default, mean squared error-optimal\n#'   bandwidth selected for each grid point); or (2) \\code{\"imse-dpi\"} (integrated MSE-optimal bandwidth,\n#'   common for all grid points); (3) \\code{\"mse-rot\"} (rule-of-thumb bandwidth with Gaussian\n#'   reference model); and (4) \\code{\"imse-rot\"} (integrated rule-of-thumb bandwidth with Gaussian\n#'   reference model).\n#' @param p Integer, nonnegative, the order of the local-polynomial used to construct point\n#'   estimates. (Default is 2.)\n#' @param v Integer, nonnegative, the derivative of distribution function to be estimated. \\code{0} for\n#'   the distribution function, \\code{1} (default) for the density funtion, etc.\n#' @param kernel String, the kernel function, should be one of \\code{\"triangular\"}, \\code{\"uniform\"} or\n#'   \\code{\"epanechnikov\"}.\n#' @param Cweights Numeric vector or one dimensional matrix / data frame, the weights used\n#'   for counterfactual distribution construction. Should have the same length as sample size.\n#'   This option will be ignored if \\code{bwselect} is \\code{\"ROT\"} or \\code{\"IROT\"}.\n#' @param Pweights Numeric vector or one dimensional matrix / data frame, the weights used\n#'   in sampling. Should have the same length as sample size, and nonnegative.\n#'   This option will be ignored if \\code{bwselect} is \\code{\"ROT\"} or \\code{\"IROT\"}.\n#' @param regularize \\code{TRUE} (default) or \\code{FALSE}, whether the bandwidth should be\n#'   regularized. When set to \\code{TRUE}, the bandwidth is chosen such that at least 20 + \\code{p} + 1\n#'   are available locally.\n#'\n#' @return\n#' \\item{BW}{A matrix containing (1) \\code{grid} (grid points), (2) \\code{bw} (bandwidths), and\n#'   (3) \\code{nh} (effective/local sample sizes).}\n#' \\item{opt}{A list containing options passed to the function.}\n#'\n#' @references\n#' M. D. Cattaneo, M. Jansson and X. Ma. (2017a). \\href{http://www-personal.umich.edu/~cattaneo/papers/Cattaneo-Jansson-Ma_2017_LocPolDensity.pdf}{Simple Local Polynomial Density Estimators}. Working Paper, University of Michigan.\n#'\n#' M. D. Cattaneo, M. Jansson and X. Ma. (2017b). \\href{http://www-personal.umich.edu/~cattaneo/papers/Cattaneo-Jansson-Ma_2017_lpdensity.pdf}{\\code{lpdensity}: Local Polynomial Density Estimation and Inference}. Working Paper, University of Michigan.\n#'\n#' @author\n#' Matias D. Cattaneo, University of Michigan. \\email{cattaneo@umich.edu}.\n#'\n#' Michael Jansson, University of California, Berkeley. \\email{mjansson@econ.berkeley.edu}.\n#'\n#' Xinwei Ma (maintainer), University of Michigan. \\email{xinweima@umich.edu}.\n#'\n#' @seealso \\code{\\link{lpdensity}}.\n#'\n#' @examples\n#' set.seed(42); X <- rnorm(1000)\n#' summary(lpbwdensity(X))\n#'\n#' @export\nlpbwdensity <- function(data, grid=NULL, bwselect=c(\"mse-dpi\", \"imse-dpi\", \"mse-rot\", \"imse-rot\"),\n                        p=NULL, v=NULL,\n                        kernel=c(\"triangular\", \"uniform\", \"epanechnikov\"),\n                        Cweights=NULL, Pweights=NULL, regularize=TRUE) {\n  ################################################################################\n  # Input Error Handling\n  ################################################################################\n  # data\n  data <- as.vector(data)\n  if (any(is.na(data))) {\n    warning(\"Missing data will be ignored.\\n\")\n    data <- data[!is.na(data)]\n  }\n  n <- length(data)\n  if (!is.numeric(data) | length(data)==0) {\n    stop(\"Data has to be numeric, and cannot be empty.\\n\")\n  }\n\n  # grid\n  if (length(grid) == 0) {\n    flag_no_grid <- TRUE\n    grid <- quantile(data, seq(from=0.05, to=0.95, by=0.05))\n    ng <- length(grid)\n  } else {\n    flag_no_grid <- FALSE\n    grid <- as.vector(grid)\n    ng <- length(grid)\n    if(!is.numeric(grid)) {\n      stop(\"Grid points has to be numeric.\\n\")\n    }\n  }\n\n  # bwselect\n  if (length(bwselect) == 0) {\n    bwselect <- \"mse-dpi\"\n  } else {\n    bwselect <- tolower(bwselect[1])\n  }\n  ### BACKWARD COMPATIBILITY FOR VERSION 0.1\n  if (bwselect == \"mse\" ) { bwselect <- \"mse-dpi\" }\n  if (bwselect == \"imse\") { bwselect <- \"imse-dpi\" }\n  if (bwselect == \"rot\" ) { bwselect <- \"mse-rot\" }\n  if (bwselect == \"irot\") { bwselect <- \"imse-rot\" }\n  ### END BACKWARD COMPATIBILITY FOR VERSION 0.1\n  if (!bwselect%in%c(\"mse-dpi\", \"imse-dpi\", \"mse-rot\", \"imse-rot\")) stop(\"Incorrect bandwidth selection method specified.\\n\")\n\n  # p\n  if (length(p) == 0) {\n    flag_no_p <- TRUE\n    p <- 2\n  } else if ((length(p) != 1) | !(p[1]%in%0:20)) {\n    stop(\"Polynomial order p incorrectly specified.\\n\")\n  } else {\n    flag_no_p <- FALSE\n  }\n\n  # v\n  if (length(v) == 0) {\n    flag_no_v <- TRUE\n    v <- min(p, 1)\n  } else if ((length(v) > 1) | !(v[1]%in%c(0:20)) | (v[1]>p)) {\n    stop(\"Derivative order v incorrectly specified.\\n\")\n  } else {\n    flag_no_v <- FALSE\n  }\n\n  # kernel\n  if (length(kernel) == 0) {\n    flag_no_kernel <- TRUE\n    kernel <- \"triangular\"\n  } else {\n    kernel <- tolower(kernel)\n    kernel <- kernel[1]\n    if (!kernel%in%c(\"triangular\", \"uniform\", \"epanechnikov\")) {\n      stop(\"Kernel function incorrectly specified.\\n\")\n    } else {\n      flag_no_kernel <- FALSE\n    }\n  }\n\n  # Cweights\n  if (length(Cweights) == 0) {\n    flag_no_Cweights <- TRUE\n    Cweights <- rep(1, n)\n  } else if (!is.numeric(Cweights)) {\n    stop(\"Counterfactual weights incorrectly specified.\\n\")\n  } else if (length(Cweights) != n) {\n    stop(\"Counterfactual weights has to be the same length as sample.\\n\")\n  } else {\n    flag_no_Cweights <- FALSE\n  }\n\n  # Pweights\n  if (length(Pweights) == 0) {\n    flag_no_Pweights <- TRUE\n    Pweights <- rep(1, n)\n  } else if (!is.numeric(Pweights)) {\n    stop(\"Probability weights incorrectly specified.\\n\")\n  } else if (length(Pweights) != n) {\n    stop(\"Probability weights has to be the same length as sample.\\n\")\n  } else if (any(Pweights < 0)) {\n    stop(\"Probability weights has to be nonnegative.\\n\")\n  } else{\n    flag_no_Pweights <- FALSE\n  }\n\n  # regularize\n  if (length(regularize) == 0) {\n    regularize <- FALSE\n  } else if (length(regularize) > 1 | !regularize[1]%in%c(TRUE, FALSE)) {\n    stop(\"Regularization parameter incorrectly specified.\\n\")\n  }\n\n  ################################################################################\n  # Sample trimming\n  ################################################################################\n  trim_index <- (Pweights == 0)\n  if (all(trim_index)) {\n    stop(\"All weights are zero.\\n\")\n  }\n  if (any(trim_index)) {\n    data <- data[!trim_index]\n    Cweights <- Cweights[!trim_index]\n    Pweights <- Pweights[!trim_index]\n  }\n  if (abs(sum(Cweights * Pweights)) <= .Machine$double.eps * 10) {\n    stop(\"Composited weights (Cweights * Pweights) are numerically zero.\\n\")\n  }\n  if (length(data) < 50 + p + 1) stop(\"Not enough observations.\\n\")\n\n  ################################################################################\n  # Bandwidth Estimation\n  ################################################################################\n\n  if (bwselect == \"mse-dpi\") {\n    bw <- bw_MSE(data=data, grid=grid, p=p, v=v, kernel=kernel, Cweights=Cweights, Pweights=Pweights, regularize=regularize)\n  } else if (bwselect == \"imse-dpi\") {\n    bw <- bw_IMSE(data=data, grid=grid, p=p, v=v, kernel=kernel, Cweights=Cweights, Pweights=Pweights, regularize=regularize)\n  } else if (bwselect == \"mse-rot\") {\n    bw <- bw_ROT(data=data, grid=grid, p=p, v=v, kernel=kernel, regularize=regularize)\n  } else {\n    bw <- bw_IROT(data=data, grid=grid, p=p, v=v, kernel=kernel, regularize=regularize)\n  }\n\n  BW <- cbind(grid, bw)\n  colnames(BW) <- c(\"grid\", \"bw\")\n  rownames(BW) <- 1:ng\n\n  nh <- rep(NA, ng)\n  for (i in 1:ng) {\n    nh[i] <- sum(abs(data-grid[i]) <= BW[i, \"bw\"])\n  }\n\n  BW <- cbind(grid, bw, nh)\n  colnames(BW) <- c(\"grid\", \"bw\", \"nh\")\n  rownames(BW) <- 1:ng\n\n  Result <- list(BW=BW,\n                 opt=list(p=p, v=v, kernel=kernel, n=n, ng=ng,\n                          bwselect=bwselect,\n                          data_min=min(data), data_max=max(data),\n                          grid_min=min(grid), grid_max=max(grid)))\n\n  class(Result) <- \"CJMlpbwdensity\"\n\n\n\n  return (Result)\n}\n\n################################################################################\n#' Internal function.\n#'\n#' @param x Class \\code{CJMlpbwdensity} objects.\n#'\n#' @keywords internal\n#' @export\nprint.CJMlpbwdensity <- function(x, ...) {\n\n  cat(\"Call: lpbwdensity\\n\\n\")\n\n  cat(paste(\"Sample size                                   \", x$opt$n,        \"\\n\", sep=\"\"))\n  cat(paste(\"Polynomial order for point estimation (p=)    \", x$opt$p,        \"\\n\", sep=\"\"))\n  cat(paste(\"Order of derivative estimated         (v=)    \", x$opt$v,        \"\\n\", sep=\"\"))\n  cat(paste(\"Kernel function                               \", x$opt$kernel,   \"\\n\", sep=\"\"))\n  cat(paste(\"Bandwidth method                              \", x$opt$bwselect, \"\\n\", sep=\"\"))\n  cat(\"\\n\")\n\n  cat(\"Use summary(...) to show bandwidths.\\n\")\n}\n\n################################################################################\n#' Internal function.\n#'\n#' @param object Class \\code{CJMlpbwdensity} objects.\n#'\n#' @keywords internal\n#' @export\nsummary.CJMlpbwdensity <- function(object, ...) {\n  x <- object\n  args <- list(...)\n  if (is.null(args[['sep']]))   { sep <- 5 } else { sep <- args[['sep']] }\n\n  cat(\"Call: lpbwdensity\\n\\n\")\n\n  cat(paste(\"Sample size                           (n=)    \", x$opt$n,        \"\\n\", sep=\"\"))\n  cat(paste(\"Polynomial order for point estimation (p=)    \", x$opt$p,        \"\\n\", sep=\"\"))\n  if (x$opt$v == 0) {\n  cat(paste(\"Distribution function estimated       (v=)    \", x$opt$v,        \"\\n\", sep=\"\"))\n  } else if (x$opt$v == 1) {\n  cat(paste(\"Density function estimated            (v=)    \", x$opt$v,        \"\\n\", sep=\"\"))\n  } else {\n  cat(paste(\"Order of derivative estimated         (v=)    \", x$opt$v,        \"\\n\", sep=\"\"))\n  }\n  cat(paste(\"Kernel function                               \", x$opt$kernel,   \"\\n\", sep=\"\"))\n  cat(paste(\"Bandwidth selection method                    \", x$opt$bwselect, \"\\n\", sep=\"\"))\n  cat(\"\\n\")\n\n  ### print output\n  cat(paste(rep(\"=\", 14 + 10 + 8), collapse=\"\")); cat(\"\\n\")\n\n  cat(format(\"grid\"            , width=14, justify=\"right\"))\n  cat(format(\"bw\"              , width=10, justify=\"right\"))\n  cat(format(\"Eff.n\"           , width=8 , justify=\"right\"))\n  cat(\"\\n\")\n\n  cat(paste(rep(\"=\", 14 + 10 + 8), collapse=\"\")); cat(\"\\n\")\n\n  for (j in 1:nrow(x$BW)) {\n    cat(format(toString(j), width=4))\n    cat(format(sprintf(\"%6.4f\", x$BW[j, \"grid\"]), width=10, justify=\"right\"))\n    cat(format(sprintf(\"%6.4f\", x$BW[j, \"bw\"])  , width=10, justify=\"right\"))\n    cat(format(sprintf(\"%8.0f\", x$BW[j, \"nh\"])  , width=8 , justify=\"right\"))\n    cat(\"\\n\")\n    if (is.numeric(sep)) if (sep > 0) if (j %% sep == 0) {\n      cat(paste(rep(\"-\", 14 + 10 + 8), collapse=\"\")); cat(\"\\n\")\n    }\n  }\n\n  cat(paste(rep(\"=\", 14 + 10 + 8), collapse=\"\")); cat(\"\\n\")\n\n}\n\n\n",
    "created" : 1499456529374.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2470475458",
    "id" : "2F6504AE",
    "lastKnownWriteTime" : 1499456575,
    "last_content_update" : 1499456575931,
    "path" : "~/Dropbox/0_Research/2017_lp_density/Package_R_lpdensity/lpdensity/R/lpbwdensity.R",
    "project_path" : "R/lpbwdensity.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}