sapply(y, function(y) {
integrate(function(x) x^i * y^(j-1) * 0.75^2 *
(1-x^2) * (1-y^2), low, y)$value
})
}, low, up)$value +
integrate(function(y) {
sapply(y, function(y) {
integrate(function(x) x^(i-1) * y^j * 0.75^2 *
(1-x^2) * (1-y^2), y, up)$value
})
}, low, up)$value
} else {
G[i,j] <- integrate(function(y) {
sapply(y, function(y) {
integrate(function(x) x^i * y^(j-1) *
(1-abs(x)) * (1-abs(y)), low, y)$value
})
}, low, up)$value +
integrate(function(y) {
sapply(y, function(y) {
integrate(function(x) x^(i-1) * y^j *
(1-abs(x)) * (1-abs(y)), y, up)$value
})
}, low, up)$value
}
}
}
return(G)
}
# Generate constant matrices
if (length(x) == 1) {
S  <- Sgenerate(         p = p, low = -1, up = 1*(x < 1), kernel = kernel)
C1 <- Cgenerate(k = p+1, p = p, low = -1, up = 1*(x < 1), kernel = kernel)
C2 <- Cgenerate(k = p+2, p = p, low = -1, up = 1*(x < 1), kernel = kernel)
G  <- Ggenerate(         p = p, low = -1, up = 1*(x < 1), kernel = kernel)
const1 <- factorial(v) / factorial(p) * (solve(S) %*% C1)[v+1]
const2 <- factorial(v) * (solve(S) %*% C2)[v+1]
const3 <- factorial(v)^2 * (solve(S) %*% G %*% solve(S))[v+1, v+1]
} else {
S  <- Sgenerate(         p = p, low = -1, up = 1, kernel = kernel)
C1 <- Cgenerate(k = p+1, p = p, low = -1, up = 1, kernel = kernel)
C2 <- Cgenerate(k = p+2, p = p, low = -1, up = 1, kernel = kernel)
G  <- Ggenerate(         p = p, low = -1, up = 1, kernel = kernel)
const1 <- factorial(v) / factorial(p) * (solve(S) %*% C1)[v+1]
const2 <- factorial(v) * (solve(S) %*% C2)[v+1]
const3 <- factorial(v)^2 * (solve(S) %*% G %*% solve(S))[v+1, v+1]
}
# Generate population quantities
F1 <- F2 <- Fp1 <- Fp2 <- c()
for (i in 1:length(x)) {
F1  <- c(F1 , normalDGP(x[i], v=1))
F2  <- c(F2 , normalDGP(x[i], v=2))
Fp1 <- c(Fp1, normalDGP(x[i], v=p+1))
Fp2 <- c(Fp2, normalDGP(x[i], v=p+2))
}
# Define the bias and variance expression
bvExpression <- function(h) {
h^(2*p+2-2*v) * sum(
(Fp1 * const1 + h * (Fp2 / factorial(p+2) ) * const2)^2 ) +
h^(1 - 2 * v) * sum(F1) * const3 / n
}
# Optimal bandwidth
return(optimize(bvExpression, interval=c(.Machine$double.eps, 5), maximum=FALSE)$minimum)
}
#----------------------------------------
# Simulation
#----------------------------------------
ptm <- proc.time()
# Job id, from 1 to 36
for (args in 1:nrow(parList)) {
# Seed
set.seed(42)
n    <- nList[parList[args, 1]]
x    <- xList[parList[args, 2]] + 1 # shifted for convenience
v    <- vList[parList[args, 3]]
p    <- pList[parList[args, 4]] + v
cat(paste("The job ID is",   args, "\n", sep=" "))
cat(paste("n is",               n, "\n", sep=" "))
cat(paste("x is",               x, "\n", sep=" "))
cat(paste("v is",               v, "\n", sep=" "))
cat(paste("p is",               p, "\n", sep=" "))
resultMatrix <- matrix(NA, nrow = repe, ncol = 104) # collecting results
truePar <- normalDGP(x = x, v = v) # true parameter
bwMSE   <- bwDGP(x = x, n = n, v = v, p = p, kernel = "triangular") # infeasible MSE bandwidth
bwIMSE  <- bwDGP(x = qnorm(pnorm(1) * seq(0.05, 0.95, 0.05)), n = n, v = v, p = p, kernel = "triangular") # infeasible IMSE bandwidth
for (i in 1:repe) {
cat(i); cat("\n")
data <- dataGen(n)
# using infeasible MSE bandwidth
temp <- lpdensity(data = data, grid = x, bw = bwMSE, p = p, v = v, kernel = "triangular")
resultMatrix[i, 1] <- temp$Estimate[1, "bw"]
resultMatrix[i, 2] <- temp$Estimate[1, "f_p"] - truePar
resultMatrix[i, 3] <- 1 * (abs(temp$Estimate[1, "f_q"] - truePar) / temp$Estimate[1, "se_q"] <= 1.96)
resultMatrix[i, 4] <- 2 * 1.96 * temp$Estimate[7]
# using estimated MSE bandwidth
temp <- lpdensity(data = data, grid = x, bwselect = "mse-dpi", p = p, v = v, kernel = "triangular")
resultMatrix[i, 5] <- temp$Estimate[1, "bw"]
resultMatrix[i, 6] <- temp$Estimate[1, "f_p"] - truePar
resultMatrix[i, 7] <- 1 * (abs(temp$Estimate[1, "f_q"] - truePar) / temp$Estimate[1, "se_q"] <= 1.96)
resultMatrix[i, 8] <- 2 * 1.96 * temp$Estimate[1, "se_q"]
# using infeasible IMSE bandwidth
temp <- lpdensity(data = data, grid = x, bw = bwIMSE, p = p, v = v, kernel = "triangular")
resultMatrix[i, 9] <- temp$Estimate[1, "bw"]
resultMatrix[i, 10] <- temp$Estimate[1, "f_p"] - truePar
resultMatrix[i, 11] <- 1 * (abs(temp$Estimate[1, "f_q"] - truePar) / temp$Estimate[1, "se_q"] <= 1.96)
resultMatrix[i, 12] <- 2 * 1.96 * temp$Estimate[1, "se_q"]
# using estimated IMSE bandwidth
temp <- lpdensity(data = data, bwselect = "imse-dpi", p = p, v = v, kernel = "triangular")
temp <- lpdensity(data = data, grid = x, bw = temp$Estimate[1, 2], p = p, v = v, kernel = "triangular")
resultMatrix[i, 13] <- temp$Estimate[1, "bw"]
resultMatrix[i, 14] <- temp$Estimate[1, "f_p"] - truePar
resultMatrix[i, 15] <- 1 * (abs(temp$Estimate[1, "f_q"] - truePar) / temp$Estimate[1, "se_q"] <= 1.96)
resultMatrix[i, 16] <- 2 * 1.96 * temp$Estimate[1, "se_q"]
# package - stats::density
if (v == 1 & p == 1) {
# using infeasible MSE bandwidth
temp <- stats::density(x = data, bw = bwMSE, n = 1, from = x, to = x)
resultMatrix[i, 17] <- temp$bw
resultMatrix[i, 18] <- temp$y - truePar
resultMatrix[i, 19] <- NA
resultMatrix[i, 20] <- NA
# using estimated bandwidth
temp <- stats::density(x = data, n = 1, from = x, to = x)
resultMatrix[i, 21] <- temp$bw
resultMatrix[i, 22] <- temp$y - truePar
resultMatrix[i, 23] <- NA
resultMatrix[i, 24] <- NA
}
# package - GenKern
if (v == 1 &  p == 1) {
# using infeasible MSE bandwidth
temp <- GenKern::KernSec(x = data, xbandwidth = bwMSE)
resultMatrix[i, 25] <- bwMSE
tempindex <- which.min(abs(temp$xords - x))
resultMatrix[i, 26] <- temp$yden[tempindex] / 100  - truePar
resultMatrix[i, 27] <- NA
resultMatrix[i, 28] <- NA
# using estimated bandwidth
temp <- GenKern::KernSec(x = data)
resultMatrix[i, 29] <- KernSmooth::dpik(data)
tempindex <- which.min(abs(temp$xords - x))
resultMatrix[i, 30] <- temp$yden[tempindex] / 100  - truePar
resultMatrix[i, 31] <- NA
resultMatrix[i, 32] <- NA
}
# package - KernSmooth::bkde
if (v == 1 &  p == 1) {
# using infeasible MSE bandwidth
temp <- KernSmooth::bkde(x = data, bandwidth = bwMSE)
resultMatrix[i, 33] <- bwMSE
tempindex <- which.min(abs(temp$x - x))
resultMatrix[i, 34] <- temp$y[tempindex]  - truePar
resultMatrix[i, 35] <- NA
resultMatrix[i, 36] <- NA
# using estimated bandwidth
temp <- KernSmooth::bkde(x = data)
resultMatrix[i, 37] <- NA
tempindex <- which.min(abs(temp$x - x))
resultMatrix[i, 38] <- temp$y[tempindex]  - truePar
resultMatrix[i, 39] <- NA
resultMatrix[i, 40] <- NA
}
# package - KernSmooth::locpoly
temp <- KernSmooth::locpoly(x = data, drv = v-1, degree = p-1, bandwidth = bwMSE)
resultMatrix[i, 41] <- bwMSE
tempindex <- which.min(abs(temp$x - x))
resultMatrix[i, 42] <- temp$y[tempindex]  - truePar
resultMatrix[i, 43] <- NA
resultMatrix[i, 44] <- NA
resultMatrix[i, 45] <- KernSmooth::dpik(x = data)
temp <- KernSmooth::locpoly(x = data, drv = v-1, degree = p-1, bandwidth = resultMatrix[i, 45])
tempindex <- which.min(abs(temp$x - x))
resultMatrix[i, 46] <- temp$y[tempindex]  - truePar
resultMatrix[i, 47] <- NA
resultMatrix[i, 48] <- NA
# package ks::kdde
if (p == v) {
temp <- ks::kdde(x = data, h = bwMSE, deriv.order = v - 1, eval.points = x)
resultMatrix[i, 49] <- temp$h
resultMatrix[i, 50] <- temp$estimate  - truePar
resultMatrix[i, 51] <- NA
resultMatrix[i, 52] <- NA
temp <- ks::kdde(x = data, deriv.order = v - 1, eval.points = x)
resultMatrix[i, 53] <- temp$h
resultMatrix[i, 54] <- temp$estimate  - truePar
resultMatrix[i, 55] <- NA
resultMatrix[i, 56] <- NA
}
# package ks::kde
if (v == 1 & p == 1) {
temp <- ks::kde(x = data, h = bwMSE, eval.points = x)
resultMatrix[i, 57] <- temp$h
resultMatrix[i, 58] <- temp$estimate  - truePar
resultMatrix[i, 59] <- NA
resultMatrix[i, 60] <- NA
temp <- ks::kde(x = data, eval.points = x)
resultMatrix[i, 61] <- temp$h
resultMatrix[i, 62] <- temp$estimate  - truePar
resultMatrix[i, 63] <- NA
resultMatrix[i, 64] <- NA
}
#    # package ks::kde.boundary
#    # DOES NOT RUN
#    temp <- ks::kde.boundary(x = data, h = bwMSE, xmin = min(data), xmax = max(data))
#    resultMatrix[i, 65] <- temp$h
#    tempindex <- which.min(abs(temp$eval.points - x))
#    resultMatrix[i, 66] <- temp$estimate[tempindex]  - truePar
#    resultMatrix[i, 67] <- NA
#    resultMatrix[i, 68] <- NA
#
#    temp <- ks::kde.boundary(x = data, xmin = min(data), xmax = max(data))
#    resultMatrix[i, 69] <- temp$h
#    tempindex <- which.min(abs(temp$eval.points - x))
#    resultMatrix[i, 70] <- temp$estimate[tempindex]  - truePar
#    resultMatrix[i, 71] <- NA
#    resultMatrix[i, 72] <- NA
# package np::npudens
if (v == 1 & p == 1) {
temp <- np::npudens(tdat = data, edat = x, bws = bwMSE)
resultMatrix[i, 65] <- temp$bw
resultMatrix[i, 66] <- temp$dens  - truePar
resultMatrix[i, 67] <- 1 * (abs(temp$dens  - truePar) / temp$derr <= 1.96)
resultMatrix[i, 68] <- 2 * 1.96 * temp$derr
temp <- np::npudens(tdat = data, edat = x)
resultMatrix[i, 69] <- temp$bw
resultMatrix[i, 70] <- temp$dens  - truePar
resultMatrix[i, 71] <- 1 * (abs(temp$dens  - truePar) / temp$derr <= 1.96)
resultMatrix[i, 72] <- 2 * 1.96 * temp$derr
}
# package np::npuniden.boundary
if (v == 1 & p == 1) {
temp <- np::npuniden.boundary(X = data, a = min(data), b = max(data), h = bwMSE)
tempindex <- which.min(abs(data - x))
resultMatrix[i, 73] <- temp$h
resultMatrix[i, 74] <- temp$f[tempindex] - truePar
resultMatrix[i, 75] <- 1 * (abs(temp$f[tempindex] - truePar) / temp$sd.f[tempindex] <= 1.96)
resultMatrix[i, 76] <- 2 * 1.96 * temp$sd.f[tempindex]
temp <- np::npuniden.boundary(X = data, a = min(data), b = max(data))
tempindex <- which.min(abs(data - x))
resultMatrix[i, 77] <- temp$h
resultMatrix[i, 78] <- temp$f[tempindex] - truePar
resultMatrix[i, 79] <- 1 * (abs(temp$f[tempindex] - truePar) / temp$sd.f[tempindex] <= 1.96)
resultMatrix[i, 80] <- 2 * 1.96 * temp$sd.f[tempindex]
}
# package plugdensity::plugin.density
if (v == 1 & p == 1) {
resultMatrix[i, 81] <- NA
resultMatrix[i, 82] <- NA
resultMatrix[i, 83] <- NA
resultMatrix[i, 84] <- NA
temp <- plugdensity::plugin.density(x = data, xout = x)
resultMatrix[i, 85] <- temp$bw
resultMatrix[i, 86] <- temp$y  - truePar
resultMatrix[i, 87] <- NA
resultMatrix[i, 88] <- NA
}
# package sm::sm.density
if (v == 1 & p == 1) {
temp <- sm::sm.density(x = data, h = bwMSE, eval.points = x)
resultMatrix[i, 89] <- temp$h
resultMatrix[i, 90] <- temp$estimate - truePar
resultMatrix[i, 91] <- 1 * (abs(temp$estimate - truePar) / temp$se <= 1.96)
resultMatrix[i, 92] <- 2 * 1.96 * temp$se
temp <- sm::sm.density(x = data, eval.points = x)
resultMatrix[i, 93] <- temp$h
resultMatrix[i, 94] <- temp$estimate - truePar
resultMatrix[i, 95] <- 1 * (abs(temp$estimate - truePar) / temp$se <= 1.96)
resultMatrix[i, 96] <- 2 * 1.96 * temp$se
}
# package nprobust::kdrobust
if (v == 1 & p == 1) {
temp <- nprobust::kdrobust(x = data, eval = x, h = bwMSE, bwcheck = 1)
resultMatrix[i, 97] <- temp$Estimate[1, 2]
resultMatrix[i, 98] <- temp$Estimate[1, 5] - truePar
resultMatrix[i, 99] <- 1 * (abs(temp$Estimate[1, 6] - truePar) / temp$Estimate[1, 8] <= 1.96)
resultMatrix[i, 100] <- 2 * 1.96 * temp$Estimate[1, 8]
temp <- nprobust::kdrobust(x = data, eval = x)
resultMatrix[i, 101] <- temp$Estimate[1, 2]
resultMatrix[i, 102] <- temp$Estimate[1, 5] - truePar
resultMatrix[i, 103] <- 1 * (abs(temp$Estimate[1, 6] - truePar) / temp$Estimate[1, 8] <= 1.96)
resultMatrix[i, 104] <- 2 * 1.96 * temp$Estimate[1, 8]
}
}
fname <- paste("Simulations/Result", "n", parList[args, 1], "x", parList[args, 2], "v", parList[args, 3], "p", parList[args, 4], ".txt", sep = "")
write.table(resultMatrix, file = fname, sep = ",", row.names = FALSE, col.names = FALSE)
}
proc.time() - ptm
modelID <- c(25, 33, 41, 49, 57, 65, 73, 97, 81, 89, 17, 1, 9)
# Jobs/parameters
nList <- c(1000) # sample size
xList <- c(-0.25, 0) # evaluation point
vList <- c(1) # density derivative
pList <- c(0, 1) # polynomial order
for (n in 1:1) for (v in 1:1) for (p in 1:2) {
# Output matrix
Output <- matrix(NA, ncol=12, nrow=length(modelID) * 2)
for (x in 1:2) {
# Generate summary statistics
fname <- paste("Simulations/Result", "n", n, "x", x, "v", v, "p", p, ".txt", sep = "")
temp <- read.table(fname, sep=",")
for (j in 1:length(modelID)) {
index <- modelID[j]
Output[(x-1)*length(modelID) + j, c(1, 7)] <- colMeans(temp[, c(index, index+4)])
Output[(x-1)*length(modelID) + j, c(2, 8)] <- abs(colMeans(temp[, c(index+1, index+5)]))
Output[(x-1)*length(modelID) + j, c(3, 9)] <- apply(temp[, c(index+1, index+5)], MARGIN=2, FUN=sd)
Output[(x-1)*length(modelID) + j, c(4, 10)] <- sqrt(Output[(x-1)*length(modelID) + j, c(2, 8)]^2 + Output[(x-1)*length(modelID) + j, c(3, 9)]^2)
Output[(x-1)*length(modelID) + j, c(5, 11)] <- colMeans(temp[, c(index+2, index+6)])
Output[(x-1)*length(modelID) + j, c(6, 12)] <- colMeans(temp[, c(index+3, index+7)])
}
}
# Print output
cat("\n"); cat("\n")
cat("-----------------------------------------------------------------------------"); cat("\n")
cat("-----------------------------------------------------------------------------")
cat("\n"); cat("\n")
print(round(Output[1:length(modelID), ], 3))
cat("-----------------------------------------------------------------------------"); cat("\n")
print(round(Output[(length(modelID)+1):(2*length(modelID)), ], 3))
}
?install.packages
?write.csv
write.csv(x, "test.csv")
remove.packages("lpdensity")
install.packages("~/Dropbox/0_Research/01_2017_LocPolDensity/Package_R_lpdensity/Temp/lpdensity_2.0.tar.gz", repos = NULL, type = "source")
#--------------------------------------------------------------------------------
# lpdensity: Local Polynomial Density Estimation and Inference
# Matias D. Cattaneo, Michael Jansson, and Xinwei Ma
# Replication Code
#--------------------------------------------------------------------------------
#--------------------------------------------------------------------------------
# Part I: Figures and illustrations
#--------------------------------------------------------------------------------
rm(list=ls())
#--------------------------------------------------------------------------------
# Install and load the "lpdensity" and "ggplot2" packages
#--------------------------------------------------------------------------------
# install.packages("ggplot2")
# install.packages("lpdensity")
library("ggplot2")
library("lpdensity")
set.seed(42)
data <- as.data.frame(rnorm(4000, mean = -1))
data <- data[data < 0, 1, drop=FALSE]
data <- -1 * data[1:2000, 1, drop=FALSE]
colnames(data) <- c("v1")
data$pdf <- dnorm(data$v1, mean = 1, sd = 1) / pnorm(0, mean = 1, sd = 1, lower.tail = FALSE)
ggplot() + geom_histogram(data=data, aes(x=v1, y=..density..), breaks=seq(0, 4, 0.2), fill=2, col="white", alpha=0.6) +
theme_bw() + labs(x = "") +
geom_line(data=data, aes(x=v1, y=pdf))
model2 <- lpdensity(data$v1, bw = 0.5, grid = seq(0, 4, 0.05))
plot(model2, ylabel = "density") + theme(legend.position = "none")
model1 <- lpdensity(data$v1, bw = 0.5, grid = seq(0, 4, 0.5))
summary(model1)
model1$Estimate
#----------------------------------------
# lpdensity(): conventional inference
#----------------------------------------
summary(lpdensity(data$v1, bw = 0.5, p = 2, q = 2))
set.seed(123) # fix the random seed for critical value simulation
summary(model1, alpha = 0.01, sep = 3, grid = c(0, 0.5, 1, 2), CIuniform = TRUE)
lpdensity(data$v1[data$v1 < 1.5], bw = 0.5, grid = 1.5)$Estimate[, "f_p"]
lpdensity(data$v1[data$v1 > 1.5], bw = 0.5, grid = 1.5)$Estimate[, "f_p"]
dnorm(1.5, mean = 1, sd = 1) / pnorm(0, mean = 1, sd = 1, lower.tail = FALSE) # true density at 1.5
lpdensity(data$v1[data$v1 < 1.5], bw = 0.5, grid = 1.5,
scale = sum(data$v1 < 1.5)/2000)$Estimate[, "f_p"]
lpdensity(data$v1[data$v1 > 1.5], bw = 0.5, grid = 1.5,
scale = sum(data$v1 > 1.5)/2000)$Estimate[, "f_p"]
plot(model2, CItype="line", ylabel = "density") +
theme(legend.position = "none")
plot(model2, type="points", CItype="ebar", grid = seq(0, 4, 0.5), ylabel = "density") +
theme(legend.position = "none")
plot(model2, hist = TRUE, histData = data$v1, histBreaks = seq(0, 4, 0.2), ylabel = "density") +
theme(legend.position = "none")
set.seed(123) # fix the random seed for critical value simulation
plot(model2, alpha=0.1, CIuniform = TRUE, ylabel = "density") +
theme(legend.position = "none")
model1bw <- lpbwdensity(data$v1, grid = seq(0, 4, 0.5))
summary(model1bw)
model5 <- lpdensity(data$v1, grid = seq(0, 4, 0.5), bwselect = "imse-dpi")
summary(model5)
# Estimation and plot using IMSE bandwidth
model6bwIMSE <- lpbwdensity(data$v1, grid = seq(0, 4, 0.05),
bwselect = "imse-dpi")
model6 <- lpdensity(data$v1, grid = seq(0, 4, 0.05),
bw = model6bwIMSE$BW[, "bw"])
plot(model6, ylabel = "density") +
theme(legend.position = "none")
# Estimation and plot using half IMSE bandwidth
model7 <- lpdensity(data$v1, grid = seq(0, 4, 0.05),
bw = model6bwIMSE$BW[, "bw"] / 2)
plot(model7, ylabel = "density") +
theme(legend.position = "none")
xList <- c(1.5, 0.2, 0) # evaluation point
nModel <- 11 # number of models
Output <- matrix(NA, ncol=12, nrow=nModel*3)
for (x in 1:length(xList)) {
fname <- paste("ResultNormal", "x", x, ".txt", sep = "")
temp <- read.table(fname, sep=",")
for (j in 1:nModel) {
index <- (j-1) * 4
Output[(x-1)*11 + j, 1] <- mean(temp[, c(index+1)])
Output[(x-1)*11 + j, 2] <- abs(mean(temp[, c(index+2)]))
Output[(x-1)*11 + j, 3] <- sd(temp[, c(index+2)])
Output[(x-1)*11 + j, 4] <- sqrt(abs(mean(temp[, c(index+2)]))^2 + sd(temp[, c(index+2)])^2)
Output[(x-1)*11 + j, 5] <- mean(temp[, c(index+3)])
Output[(x-1)*11 + j, 6] <- mean(temp[, c(index+4)])
}
fname <- paste("ResultExp", "x", x, ".txt", sep = "")
temp <- read.table(fname, sep=",")
for (j in 1:nModel) {
index <- (j-1) * 4
Output[(x-1)*11 + j, 6 + 1] <- mean(temp[, c(index+1)])
Output[(x-1)*11 + j, 6 + 2] <- abs(mean(temp[, c(index+2)]))
Output[(x-1)*11 + j, 6 + 3] <- sd(temp[, c(index+2)])
Output[(x-1)*11 + j, 6 + 4] <- sqrt(abs(mean(temp[, c(index+2)]))^2 + sd(temp[, c(index+2)])^2)
Output[(x-1)*11 + j, 6 + 5] <- mean(temp[, c(index+3)])
Output[(x-1)*11 + j, 6 + 6] <- mean(temp[, c(index+4)])
}
}
Output <- Output[c(1:11, 13, 17, 21, 22, 24, 28, 32, 33), ]
round(Output, 3)
library(lpdensity)
?lpdensity
library(lpdensity)
?lpdensity
# Generate a random sample
set.seed(42); X <- rnorm(2000)
# Estimate density and report results
est1 <- lpdensity(data = X, bwselect = "imse-dpi")
summary(est1)
# Report results for a subset of grid points
summary(est1, grid=est1$Estimate[4:10, "grid"])
summary(est1, gridIndex=4:10)
# Report the 99% uniform confidence band
set.seed(42) # fix the seed for simulating critical values
summary(est1, alpha=0.01, CIuniform=TRUE)
# Plot the estimates and confidence intervals
plot(est1, legendTitle="My Plot", legendGroups=c("X"))
# Plot the estimates and the 99% uniform confidence band
set.seed(42) # fix the seed for simulating critical values
plot(est1, alpha=0.01, CIuniform=TRUE, legendTitle="My Plot", legendGroups=c("X"))
# Adding a histogram to the background
plot(est1, legendTitle="My Plot", legendGroups=c("X"),
hist=TRUE, histData=X, histBreaks=seq(-1.5, 1.5, 0.25))
?print.lpdensity
# Generate a random sample
set.seed(42); X <- rnorm(2000)
# Estimate density and report results
print(lpdensity(data = X, bwselect = "imse-dpi"))
# Generate a random sample
set.seed(42); X <- rnorm(2000)
# Estimate density and report results
coef(lpdensity(data = X, bwselect = "imse-dpi"))
# Generate a random sample
set.seed(42); X <- rnorm(2000)
# Estimate density and report 95% confidence intervals
est1 <- lpdensity(data = X, bwselect = "imse-dpi")
confint(est1)
# Report results for a subset of grid points
confint(est1, parm=est1$Estimate[4:10, "grid"])
confint(est1, grid=est1$Estimate[4:10, "grid"])
confint(est1, gridIndex=4:10)
# Report the 99% uniform confidence band
# Fix the seed for simulating critical values
set.seed(42); confint(est1, level=0.99, CIuniform=TRUE)
set.seed(42); confint(est1, alpha=0.01, CIuniform=TRUE)
library(lpdensity)
# Generate a random sample
set.seed(42); X <- rnorm(2000)
# Generate a density discontinuity at 0
X <- X - 0.5; X[X>0] <- X[X>0] * 2
# Density estimation, left of 0 (scaled by the relative sample size)
est1 <- lpdensity(data = X[X<=0], grid = seq(-2.5, 0, 0.05), bwselect = "imse-dpi",
scale = sum(X<=0)/length(X))
# Density estimation, right of 0 (scaled by the relative sample size)
est2 <- lpdensity(data = X[X>0],  grid = seq(0, 2, 0.05), bwselect = "imse-dpi",
scale = sum(X>0)/length(X))
# Plot
plot(est1, est2, legendTitle="My Plot", legendGroups=c("Left", "Right"))
# Plot a uniform confidence band
set.seed(42) # fix the seed for simulating critical values
plot(est1, est2, legendTitle="My Plot", legendGroups=c("Left", "Right"), CIuniform=TRUE)
# Adding a histogram to the background
plot(est1, est2, legendTitle="My Plot", legendGroups=c("Left", "Right"),
hist=TRUE, histBreaks=seq(-2.4, 2, 0.2), histData=X)
# Plot point estimates for a subset of evaluation points
plot(est1, est2, legendTitle="My Plot", legendGroups=c("Left", "Right"),
type="both", CItype="all", grid=seq(-2, 2, 0.5))
# Generate a random sample
set.seed(42); X <- rnorm(2000)
# Estimate density and report results
vcov(lpdensity(data = X, bwselect = "imse-dpi"))
?lpbwdensity
library(lpdensity)
# Generate a random sample
set.seed(42); X <- rnorm(2000)
# Construct bandwidth
bw1 <- lpbwdensity(X)
summary(bw1)
# Display bandwidths for a subset of grid points
summary(bw1, grid=bw1$BW[4:10, "grid"])
summary(bw1, gridIndex=4:10)
# Generate a random sample
set.seed(42); X <- rnorm(2000)
# Construct bandwidth
coef(lpbwdensity(X))
# Generate a random sample
set.seed(42); X <- rnorm(2000)
# Construct bandwidth
print(lpbwdensity(X))
?lpdensity
library(lpdensity)
